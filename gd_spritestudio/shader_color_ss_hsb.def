// generated argstr
static const char* shader_color_ss_hsb =
"/*!\n"
"* \file		shader_color_ss_hsb.gdshader\n"
"* \author	CRI Middleware Co., Ltd.\n"
"*/\n"
"shader_type canvas_item;\n"
"render_mode blend_mix;\n"
"\n"
"uniform float src_ratio;\n"
"uniform float dst_ratio;\n"
"uniform float dst_src_ratio;\n"
"\n"
"uniform float A_TW;\n"
"uniform float A_TH;\n"
"uniform float A_U1;\n"
"uniform float A_V1;\n"
"uniform float A_LU;\n"
"uniform float A_TV;\n"
"uniform float A_CU;\n"
"uniform float A_CV;\n"
"uniform float A_RU;\n"
"uniform float A_BV;\n"
"uniform float A_PM;\n"
"\n"
"uniform float P_0;\n"
"uniform float P_1;\n"
"uniform float P_2;\n"
"uniform float P_3;\n"
"\n"
"uniform sampler2D color;\n"
"uniform sampler2D alpha;\n"
"\n"
"uniform float use_mask;\n"
"uniform float draw_mask;\n"
"uniform float composite;\n"
"\n"
"vec4 ssCalcCompositeColor( int i, vec4 c, vec4 p )\n"
"{\n"
"	vec4	n = vec4( 1.0 );\n"
"\n"
"	if ( i == 1 ) c.rgb = c.rgb + p.rgb;\n"
"	else if ( i == 2 ) c.rgb = c.rgb - p.rgb;\n"
"	else if ( i == 3 ) c.rgb = c.rgb * p.rgb;\n"
"	else if ( i == 4 ) c.rgb = c.rgb / p.rgb;\n"
"	else if ( i == 5 ) c.rgb = n.rgb - ( n.rgb - p.rgb ) * ( n.rgb - c.rgb );\n"
"	else if ( i == 6 ) {\n"
"		if ( ( p.r + p.g + p.b ) / 3.0 < 0.5 ) { c.rgb = 2.0 * p.rgb * c.rgb; }else{ c.rgb = n.rgb - 2.0 * ( n.rgb - p.rgb ) * ( n.rgb - c.rgb ); }\n"
"	}\n"
"\n"
"	return	c;\n"
"}\n"
"\n"
"vec4 getBlendColor( vec4 c, vec4 p )\n"
"{\n"
"	return	vec4( p.rgb * src_ratio + mix( vec3( 1.0 ), p.rgb, dst_src_ratio ) * c.rgb * dst_ratio, p.a * c.a );\n"
"}\n"
"\n"
"vec4 toHSB( vec4 col )\n"
"{\n"
"	vec4	K = vec4( 0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0 );\n"
"	vec4	p = mix( vec4( col.bg, K.wz ), vec4( col.gb, K.xy ), step( col.b, col.g ) );\n"
"	vec4	q = mix( vec4( p.xyw, col.r ), vec4( col.r, p.yzx ), step( p.x, col.r ) );\n"
"\n"
"	float	d = q.x - min( q.w, q.y );\n"
"	float	e = 1.0e-10;\n"
"\n"
"	return	vec4( abs( q.z + ( q.w - q.y ) / ( 6.0 * d + e ) ), d / ( q.x + e ), q.x, col.a );\n"
"}\n"
"\n"
"vec4 toRGB( vec4 hsb )\n"
"{\n"
"	vec4	K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n"
"	vec3	p = abs( fract( hsb.xxx + K.xyz ) * 6.0 - K.www );\n"
"\n"
"	return	vec4( hsb.z * mix( K.xxx, clamp( p - K.xxx, 0.0, 1.0 ), hsb.y ), hsb.w );\n"
"}\n"
"\n"
"vec4 shiftHSB( vec4 hsb, float fRatioH, float fRatioS, float fRatioB )\n"
"{\n"
"	vec4	shift = hsb;\n"
"\n"
"	shift.x += fRatioH;\n"
"	shift.y = clamp( hsb.y + fRatioS, 0.0, 1.0 );\n"
"	shift.z = clamp( hsb.z + fRatioB, 0.0, 1.0 );\n"
"\n"
"	if ( shift.x < 0.0 ) {\n"
"		shift.x += 1.0;\n"
"	}\n"
"	if ( shift.x > 1.0 ) {\n"
"		shift.x -= 1.0;\n"
"	}\n"
"\n"
"	return	shift;\n"
"}\n"
"\n"
"vec4 adjustHSB( vec4 col, float fRatioH, float fRatioS, float fRatioB )\n"
"{\n"
"	vec4	hsb;\n"
"\n"
"	hsb = toHSB( col );\n"
"\n"
"	hsb = shiftHSB( hsb, fRatioH, fRatioS, fRatioB );\n"
"\n"
"	return	toRGB( hsb );\n"
"}\n"
"\n"
"vec4 ssPreProc( vec4 col, sampler2D tex, vec2 st, inout bool pass )\n"
"{\n"
"	float	fHue = P_0;\n"
"	float	fSaturation = P_1;\n"
"	float	fBrightness = P_2;\n"
"\n"
"	if ( A_TW <= 0.0 ) {\n"
"		return	adjustHSB( col, fHue, fSaturation, fBrightness );\n"
"	}\n"
"\n"
"	vec4	Pixel = texture( tex, st );\n"
"\n"
"	return	getBlendColor( col, adjustHSB( Pixel, fHue, fSaturation, fBrightness ) );\n"
"}\n"
"\n"
"vec4 ssPostProc( vec4 c, vec4 p )\n"
"{\n"
"	float	fUm = use_mask;\n"
"	float	fDm = draw_mask;\n"
"	int		iCo = int( composite );\n"
"\n"
"//	if ( fDm >= 0.0 ) { c = ssCalcDrawMaskColor( fDm, c ); fUm = 0.0; iCo = 0; }\n"
"//	if ( fUm > 0.0 ) { c = ssCalcUseMaskColor( c ); }\n"
"	if ( iCo > 0 ) { c.rgb = c.rgb + p.rgb; }\n"
"\n"
"	return	c;\n"
"}\n"
"\n"
"void fragment()\n"
"{\n"
"	bool pass = false;\n"
"	COLOR = ssPreProc( COLOR, TEXTURE, UV, pass );\n"
"	if ( pass ) discard;\n"
"//	COLOR = ssMainProc();\n"
"//	COLOR = ssPostProc( COLOR, texture( color, SCREEN_UV, 0.0 ) );\n"
"}\n"
"";